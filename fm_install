#!/bin/bash
set -u  # treat unset variables as an error
set -o pipefail  #returns any error in the pipe, not just last command
#set -x    # uncomment for debugging.

# This script will install filemaker, either natively or as a docker container. It will optionally install nginx proxy manager.
# If Filemaker is to be run natively, it currently requires Ubuntu 22.04 and you can only have one copy of filemaker running
#
# If Filemaker is to be run as a docker container, this script will work on either Debian or Ubuntu.
# and multiple versions of filemaker can be installed.
#
# The default options will do the following:
# Install nginx proxy manager, which will look after the SSL certificate.
# By having nginx look after it, no need to reboot filemaker whenever the SSL cert is renewed.
# Filemaker is installed as a docker container.
# In this case, no need to expose any ports as nginx will talk to filemakaer over a docker network.
#
# If filemaker is installed as a docker container without nginx, ports 443 and 5003 are exposed.

# This script has been tested on Debian 12 and Ubuntu 24.04 on both AMD64 and ARM64 hardware for docker installs
# and on Ubuntu 22.04 when installing Filemaker natively.

OPTIONS=$1
if [ "$OPTIONS" != "token" ] && [ "$OPTIONS" != "dev" ] && [ "$OPTIONS" != "run" ] && [ "$OPTIONS" != "restore" ]; then
  echo "script must be run with 1 option. They are:"
  echo
  echo "token - Get an admin api token, display it and exit. The admin api only gives out so many tokens"
  echo "dev - once you have a token, manually update the token variable so the script can be rerun many times"
  echo "run - run the script as it would be run in production"
  echo "restore - once the server has been installed and is up and running ok, restore data from the old servr"
exit 1
fi

#Work out what flavour and version of Linux this is.
if [ -f /etc/os-release ]; then
  . /etc/os-release
  #This will set various variables. This script will use:
  # "ID"  Should be either "debian" or "ubuntu"
  # "VERSION_ID"  Will be 11 or 12 or similar for Debian. "22.04" "24.04" etc for Ubuntu
  # "PRETTY_NAME" Will be something like "Ubuntu 22.04.5 LTS"

   #Use variables with more meaningful name for later in the script
  LINUX_DISTRO=$ID
  LINUX_VERSION=$VERSION_ID
else
  echo "Unable to work out what Linux is running."
  exit 9
fi

case `uname -m` in
  x86_64) ARCH="amd64" ;;
  aarch64) ARCH="arm64";;
  *) ARCH="unknown" ;;
esac

if [ "$ARCH" == "unknown" ]; then
  echo "Architecture can't be determined. This script can only run on amd64 or arm64 platforms"
  exit 9
fi

echo "Detected this system as $PRETTY_NAME running on $ARCH hardware"


# If this is to copy data from old server to new, before running this script
# - Make sure the below variables are set

# On existing production server
# - Disable all scheduled tasks
# - close all databases.
# - clone this repo to the new server and run it.


#
# Required
# ALL The following variables are required
# These are split into 3 groups.
# 1. Those that have to be changed to suit your environment for this to work
# 2. Those that are recommended to be changed.
# 3. Those that cannot be changed.
# 4. Variables that just set options for some

# Many of these variable contain sensitive info, so the real versions of these are kept
# in a private directory which git ignores.

#
#
### 1. Variables that should be carefully checked or changed for this script to work correctly.
#
SCRIPT_LOCATION=~/filemaker_install


# These ones likely do not need to be changed.
STATE=$SCRIPT_LOCATION/state
DOWNLOAD_LOCATION=$SCRIPT_LOCATION/downloads
INSTALL=$SCRIPT_LOCATION/install

#Host setup
SWAP_ENABLED=false
SWAP_SIZE=4G
SWAPPINESS=10

#Select which Filemaker to build. You can only install multiple versions on the one server if installed as docker containers.
#Only enable one of these per run of this script.
FMS=FMS1    # Latest production version
#FMS=FMS2   # Latest ETS Beta build


#Default. May be overriden later
FM_DOCKER=true    # Docker will get installed regardless. This just determines if Filemaker will be installed as a docker container.
NGINX_PROXY=true  # Install the nginx proxy manager as a docker container.
CERTBOT=false

#FMS1 settings. This is the latest production
if [ "$FMS" == "FMS1" ]; then
  #This is the setup for Southern's production filemaker server.
  FMS_VERSION=21.1.4.400
  FM_NAME=fms$FMS_VERSION
  FM_INSTALL=$INSTALL/$FM_NAME
  ASSINST=$SCRIPT_LOCATION/install/$FM_NAME/assInst
  #UBUNTU="22.04" #If Filemaker is NOT to be run in a docker container, it will only run on a specific version of Ubuntu
  DOWNLOAD_LINK=https://amazonaws.com/downloads/filemaker/fms_${FMS_VERSION}_Ubuntu22_$ARCH.zip      
        
  DOWNLOAD_FILE=fms_${FMS_VERSION}_Ubuntu22_$ARCH.zip
  DEB=filemaker-server-${FMS_VERSION}-$ARCH.deb

  #FM Server email notifications
  EMAIL_NOTIFICATIONS=true
  EMAIL_SENDER="fm@hammond.zone"
  EMAIL_REPLY="noreply@hammond.zone"
  EMAIL_RECIPIENTS="craig@blueskyflying.com.au"
  SMTP_SERVER="aws.smtp.com"
  SMTP_USER="AIDDS4Z7CTMRN"
  SMTP_PASSWORD="BjbVzwOLdzDTjpY3wH31aUIAszSDz8"

  # Filemaker Server scripts from one of the databases are scheduled to run automatically on the server.
  # The automatic installation of these scripts can only happen when a database with those scripts included is
  # installed on the server. The below database is a cutdown version of the production database that just
  # has dummy scripts with the same name as in production.
  # Once the scripts have been setup on the server to run, this cutdown database can be replaced with 
  # the production one and the schedule Filemaker scripts will still run.

  # This is the user and password of that database so those scripts can be setup.
  FM_AUTOSCRIPT_INSTALL=true
  FM_AUTOSCRIPT_DATABASE_NAME="SA_MASTER_CLONE"
  FM_AUTOSCRIPT_USER="admin"
  FM_AUTOSCRIPT_PASS="So14"

  # Microsoft OAuth settings.
  EXTERNAL_AUTH=true
  OAuthID="a69asdfa2c"
  OAuthKey="kU~0sadf"
  OAuthDirectoryID="dsdafedf"

  FM_ADMIN_USER=admin
  FM_ADMIN_PASSWORD=password
  FM_ADMIN_PIN=1234

  PARALLEL_BACKUPS=true

  # Setup info based on if it's to be run natively or in a docker container
  if [ "$FM_DOCKER" == "true" ]; then
    CPUS=3
    MEMORY="16G"

    FM_DATA=~/docker/filemaker/$FM_NAME/Data
    FM_LOGS=~/docker/filemaker/$FM_NAME/Logs
    FM_DATABASES=$FM_DATA/Databases
  
    FM_CONTAINERS=$FM_DATA/Containers
    FM_BACKUPS=$FM_DATA/Backups

    #If you change the below variables, consider if the same variables after the "else" statement need changing
    HOME_LOCATION=/opt/FileMaker
    #SCRIPT_LOCATION=$HOME_LOCATION/filemaker-install   # this assumes you did the git clone from the home directory.
    DRIVE_DATABASES=/dev/nvme1n1
    DRIVE_CONTAINERS=/dev/nvme2n1
    DRIVE_BACKUPS=/dev/nvme3n1

  else
    # Running FM natively.
    UBUNTU="22.04"
    FM_DATA=/opt/FileMaker
    FM_DATABASES=$FM_DATA/Data/Databases
    FM_CONTAINERS=$FM_DATA/Data/Containers
    FM_BACKUPS=$FM_DATA/Backups

    #If you change the below variables, consider if the same variables before the above "else" statement need changing
    HOME_LOCATION=/home/ubuntu
    # SCRIPT_LOCATION=$HOME_LOCATION/filemaker-install   # this assumes you did the git clone from the home directory.
    ASSISTED_FILE=$SCRIPT_LOCATION/fminstall/AssInst.txt
    INSTALLED_SCRIPTS=$HOME_LOCATION/filemaker-scripts     # Various scripts used after the install are put here.

    ### Be Careful. These drives will be partitioned and formatted. ###
    #DRIVE_DATABASES=/dev/nvme2n1
    #DRIVE_CONTAINERS=/dev/nvme1n1
    #DRIVE_BACKUPS=/dev/nvme3n1
  fi

  DATA=$FM_DATA/$NAME
fi #FMS1
###########################################################################################

if [ "$FMS" == "FMS2" ]; then
  #FMS2 settings. This is the latest ETS Beta build
  NAME=ets22-0-1-32

  UBUNTU="24.04" #If Filemaker is NOT to be run in a docker container, it will only run on a specific version of Ubuntu

  if [ "$ARCH" == "arm64" ]; then
    DOWNLOAD_LINK=https://amazonaws.com/downloads/filemaker/fms_32_ubuntu24arm_ets_v4gl5.zip
    DOWNLOAD_FILE=fms_32_ubuntu24arm_ets_v4gl5.zip
  else
  # ETS AMD64. Beta
    DOWNLOAD_LINK=https://amazonaws.com/downloads/filemaker/fms_32_ubuntu24_ets_1nuvu.zip
    DOWNLOAD_FILE=fms_32_ubuntu24_ets_1nuvu.zip
  fi
  DEB=filemaker-server-22.0.1.32-$ARCH.deb

  ## more shit to go there.
fi #FMS2


#
#
### 2. Variables that should be changed to suit, but script will work as is, except for the "secret" stuff below. These need to be set..
#
#

TIMEZONE=Australia/Melbourne
HOSTNAME=cocko.hammond.zone

#
#
### SECRETS
#
# Many of the above variables need to be overriden with the proper values. hostname, usernames and passwords
# for obvious reasons, they aren't included in a public repo, so they are kept as a seperate file which overrides many
# of the above variables.
#SECRETS=$SCRIPT_LOCATION/secrets/filemaker-install 

# Override variables with private data
#. $SECRETS/variables    # variables that override many of the above variables.
#. $SECRETS/fm_auth      # Filemaker server username and password used by various setup and post install scripts.

# Server Settings


# Optional software to install
# Install optional programs I find handy. Change this to No if not needed
# This script will install these only on the host. Not in the docker containers (if any)
GLANCES=true
NCDU=true

#
#
### 3. Variables that should not be changed.
#
#WEBROOTPATH="/opt/FileMaker/FileMaker Server/NginxServer/htdocs/httpsRoot/"

########################
### END OF VARIABLES ###
########################

# load in functions. Not sure if will work once script is linked to user home directory.
. $SCRIPT_LOCATION/functions

# This script needs to be run multiple times.
# The state directory is used so that this script can keep track of where it is up to between these runs
if [ ! -d $STATE ]; then
  echo "creating state directory"
  mkdir $STATE || { echo "Couldn't create state directory"; exit 1; }
fi

if [ "$SWAP_ENABLED" == "true" ] && [ ! -f $STATE/swap ]; then
  sudo fallocate -l $SWAP_SIZE /swapfile && \
  sudo chmod 600 /swapfile && \
  sudo mkswap /swapfile && \
  sudo swapon /swapfile && \
  sudo swapon --show && \
  echo "/swapfile none swap sw 0 0" | sudo tee -a /etc/fstab && \
  echo "vm.swappiness=$SWAPPINESS" | sudo tee -a /etc/sysctl.conf || { echo "unable to configure swap"; exit 1; }
  touch $STATE/swap
fi


# Link this script to the home directory so it can easily be run it after login
if [ ! -f ~/fm_install ]; then
  ln -s $SCRIPT_LOCATION/fm_install ~/fm_install
  echo
  echo "----------------------------------------------------------------------------------------"
  echo "When this install script asks you to reboot and rerun the script, it is copied to ~/fm_install.sh"
  read -p "Press return to continue "
fi

#Setup bash the way I like it.
if [ ! -f $STATE/bash-setup ]; then 
  echo "#Added by filemaker install script" >> ~/.bashrc
  echo "alias l='ls'" >> ~/.bashrc
  echo "alias ll='ls -l'" >> ~/.bashrc
  echo "alias lll='ls -la'" >> ~/.bashrc
  echo "alias update='sudo apt update && sudo apt upgrade -y'" >> ~/.bashrc
  if [[ "$GLANCES" == "true" ]]; then
    echo "alias g='glances --theme-white -1'" >> ~/.bashrc
  fi
  touch $STATE/bash-setup
fi

type unzip &> /dev/null || sudo apt install unzip -y || { echo "unable to install unzip"; exit 1; }
type jq &> /dev/null || sudo apt install jq -y || { echo "unable to install jq"; exit 1; }
#using "type parted", even with sudo doesn't work on debian.
sudo which parted &> /dev/null || sudo apt install parted -y || { echo "unable to install parted"; exit 1; }

if [[ "$GLANCES" == "true" ]] && ! type glances &> /dev/null; then
  sudo apt install glances -y
fi
if [[ "$NCDU" == "true" ]] && ! type ncdu &> /dev/null; then
  sudo apt install ncdu -y
fi

#
#
# Do various checks around if Filemaker.
# If installing FM natively and it's already installed, it will be an upgrade

echo "checking if fm is installed if docker isn't to be used"
if [[ "$FM_DOCKER" == "false" ]] && type fmsadmin &> /dev/null; then
  printf "\nYou are attempting to install Filemaker Natively, but it's already installed.\n"
  echo "If you run the installation file, it will upgrade the existing Filemaker"
  read -p "Type in   upgrade     to upgrade the existing filemaker. Anything else will abort this script: " input
  if [ "$input" != "upgrade" ]; then
    exit
  fi
  upgrade_filemaker
  exit
fi

#If it not to be run in docker, check we are on the correct version of Ubuntu
if [[ "$FM_DOCKER" == "false" ]] && { [[ "$LINUX_DISTRO" != "ubuntu" || "$LINUX_VERSION" != "$UBUNTU" ]]; }; then
  echo "To run Filemaker natively, it must be installed on Ubuntu $UBUNTU"
  echo "This appears to be $LINUX_DISTRO $LINUX_VERSION"
  echo "Either set the variable 'FM_DOCKER' = true, or run this on the correct version of Ubuntu"
  exit 9
fi

# Create directory where post install filemaker scripts will live  (only applicable as is, if not going in a container)
#if [ ! -d $INSTALLED_SCRIPTS ]; then
#  mkdir $INSTALLED_SCRIPTS || { echo "Couldn't create filemaker scripts directory: $INSTALLED_SCRIPTS"; exit 1; }
#fi

if ! type docker &> /dev/null; then 
  echo "Installing Docker"
  # Add Docker's official GPG key:
  sudo apt-get update
  sudo apt-get install ca-certificates curl
  sudo install -m 0755 -d /etc/apt/keyrings
  sudo curl -fsSL https://download.docker.com/linux/$LINUX_DISTRO/gpg -o /etc/apt/keyrings/docker.asc
  sudo chmod a+r /etc/apt/keyrings/docker.asc

  # Add the repository to Apt sources:
  if [ "$LINUX_DISTRO" == "ubuntu" ]; then
    echo \
      "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
      $(. /etc/os-release && echo "${UBUNTU_CODENAME:-$VERSION_CODENAME}") stable" | \
      sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
  else
    echo \
      "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/debian \
      $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
      sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
  fi
  sudo apt-get update
  sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin -y \
    ||  { echo "Docker installation failed"; exit 1; }
  sudo usermod -aG docker $USER

  sudo docker ps ||  { echo "docker ps didn't work. Something went wrong with the Docker installation"; exit 1; }
  echo 'logoff and on again. docker ps should now work without needing sudo'
  logoff_rerun
fi


if [ ! -f $STATE/timezone-set ]; then 
  sudo timedatectl set-timezone $TIMEZONE || { echo "Error setting timezone"; exit 1; }
  touch $STATE/timezone-set
fi

if [ ! -f $STATE/hostname-set ]; then
  sudo hostnamectl set-hostname $HOSTNAME || { echo "Error setting hostname"; exit 1; }
  touch $STATE/hostname-set
fi

#Make sure the system is up to date and reboot if necessary
if [ ! -f $STATE/apt-upgrade ]; then
  sudo apt update || { echo "Error running apt update"; exit 1; }
  sudo DEBIAN_FRONTEND=noninteractive apt upgrade -y || { echo "Error running apt upgrade"; exit 1; }
  touch $STATE/apt-upgrade
  if [ -f /var/run/reboot-required ]; then
    echo "Reboot is required. Reboot then rerun this script   ~./fm_install"
    reboot_rerun
  fi
fi

# Partition, format and attached the additional drives.
#

if [ ! -f $STATE/drive-setup ]; then

  if [[ "$DRIVE_DATABASES" != "false" ]]; then
    sudo parted -s $DRIVE_DATABASES mklabel gpt || { echo "error with mklabel on database drive"; exit 1; }
    sudo parted -s $DRIVE_DATABASES mkpart Databases 0% 100% || { echo "error with mkpark on database drive"; exit 1; }
    sleep 1  ## sometimes, if the mkfs runs too quickly after the partition, it fails
    sudo mkfs.ext4 -m 0 ${DRIVE_DATABASES}p1 || { echo "error with mkfs on database drive"; exit 1; }  
  fi

  if [[ "$DRIVE_CONTAINERS" != "false" ]]; then
    sudo parted -s $DRIVE_CONTAINERS mklabel gpt || { echo "error with mklabel on containers drive"; exit 1; }
    sudo parted -s $DRIVE_CONTAINERS mkpart Containers 0% 100% || { echo "error with mkpart on containers drive"; exit 1; }
    sleep 1
    sudo mkfs.ext4 -m 0 ${DRIVE_CONTAINERS}p1 || { echo "error with mkfs on containers drive"; exit 1; }
  fi

  if [[ "$DRIVE_BACKUPS" != "false" ]]; then
    sudo parted -s $DRIVE_BACKUPS mklabel gpt || { echo "error with mklabel on backup drive"; exit 1; }
    sudo parted -s $DRIVE_BACKUPS mkpart Backups 0% 100% || { echo "error with mkpart on backup drive"; exit 1; }
    sleep 1
    sudo mkfs.ext4 -m 0 ${DRIVE_BACKUPS}p1 || { echo "error with mkfs on backup drive"; exit 1; }
  fi
  touch $STATE/drive-setup
fi

#Download filemaker
mkdir -p $DOWNLOAD_LOCATION $SCRIPT_LOCATION/install || { echo "Error creating download/install directories"; exit 9; }

#Download file doesn't exist, so get it.
if [ ! -f $DOWNLOAD_LOCATION/$DOWNLOAD_FILE ]; then
   wget $DOWNLOAD_LINK -P $DOWNLOAD_LOCATION  || { echo "Downloading Filemaker failed"; exit 9; }
fi

#unzip install files if they don't exist
if [ ! -f $INSTALL/$FM_NAME/$DEB ]; then
  unzip -u $DOWNLOAD_LOCATION/$DOWNLOAD_FILE -d $INSTALL/$FM_NAME || { echo "unzipping of FMS install file failed"; exit 9; }
fi


#Install filemaker
if [ ! -f $STATE/filemaker-installed ]; then

# for dev, delete existing containers
  docker stop $FM_NAME-primary
  docker rm $FM_NAME-primary


  # Create the assisted install file.
  cd $INSTALL/$FM_NAME || { echo "Unable to cd into filemaker installation directory"; exit 9; }
  echo "[Assisted Install]" > AssInst
  echo "License Accepted=1" >> AssInst
  echo "Deployment Options=0" >> AssInst
  echo "Admin Console User=$FM_ADMIN_USER" >> AssInst
  echo "Admin Console Password=$FM_ADMIN_PASSWORD" >> AssInst
  echo "Admin Console PIN=$FM_ADMIN_PIN" >> AssInst
  echo "Filter Databases=0" >> AssInst
  echo "Remove Sample Database=1" >> AssInst
  echo "Use HTTPS Tunneling=1" >> AssInst

  echo "Install Filemaker Server"

  # Create the prep container just containing Ubuntu
  if [[ "$FM_DOCKER" == "true" ]]; then
    docker build -f $SCRIPT_LOCATION/Dockerfile.$FM_NAME -t fms:prep${FM_NAME} . || { echo "FMS prep build failed"; exit 9; }

    # Run the prep container, then install Filemaker into it
    docker run --detach \
     --hostname ${FM_NAME}-primary \
     --name ${FM_NAME}-primary \
     --privileged \
     --volume $INSTALL/$FM_NAME:/install \
     --volume $FM_DATA:"/opt/FileMaker/FileMaker Server/Data" \
     --volume $FM_LOGS:"/opt/FileMaker/FileMaker Server/Logs" \
     fms:prep${FM_NAME} || { echo "run failed"; exit 9; }
     sleep 1
     # Thius nameserver change comes straight from Claris's docker script
     docker exec ${FM_NAME}-primary bash -c "echo 'nameserver 8.8.8.8' | tee /etc/resolv.conf > /dev/null"
  fi

  if [ "$FM_DOCKER" == "true" ]; then
    docker exec ${FM_NAME}-primary bash -c "FM_ASSISTED_INSTALL=/install/AssInst apt install /install/$DEB -y" || { echo 'Error installing Filemaker'; exit 1; }
  else
   sudo FM_ASSISTED_INSTALL=$FM_INSTALL/AssInst apt install $FM_INSTALL/$DEB -y || { echo 'Error installing Filemaker'; exit 1; }

  fi
  touch $STATE/filemaker-installed
fi


#Create additional directories for Databases, Containers & Backups and attached drives
if [ ! -f $STATE/mount-drives ]; then
  sudo mkdir -p $FM_DATABASES $FM_CONTAINERS $FM_BACKUPS || { echo "Unable to create Data / Backup directories"; exit 1; }

  DATABASE_UUID=$(lsblk -n -o UUID ${DRIVE_DATABASES}p1)
  CONTAINER_UUID=$(lsblk -n -o UUID ${DRIVE_CONTAINERS}p1)
  BACKUP_UUID=$(lsblk -n -o UUID ${DRIVE_BACKUPS}p1)

  #Check we have UUID's for all drives
  if [ -z $DATABASE_UUID ] || [ -z $CONTAINER_UUID ] || [ -z $BACKUP_UUID ]; then
    echo "Don't have all required UUID's"
    echo DATABASE_UUID: $DATABASE_UUID
    echo CONTAINER_UUID: $CONTAINER_UUID
    echo BACKUP_UUID: $BACKUP_UUID
    exit 1
  fi
  
  if [ ! -f $STATE/fstab ]; then
    echo "UUID=$DATABASE_UUID  $FM_DATABASES ext4 defaults,nofail 0 2" | sudo tee -a /etc/fstab
    echo "UUID=$CONTAINER_UUID $FM_CONTAINERS ext4 defaults,nofail 0 2" | sudo tee -a /etc/fstab
    echo "UUID=$BACKUP_UUID $FM_BACKUPS ext4 defaults,nofail 0 2" | sudo tee -a /etc/fstab
    touch $STATE/fstab
  fi

  sudo mount -a || { echo "Error mounting additional drives. Check /etc/fstab before rerunning fm_install.sh"; exit 1; }
  sudo systemctl daemon-reload


  touch $STATE/mount-drives
fi
set -x
exit 99  #below not working. It's trying to use the host folder path within the container.

  executeCMD "sudo chown -R fmserver:fmsadmin $FM_DATABASES" "Error setting permissions on additional directories $FM_DATABASES"
  executeCMD "sudo chown -R fmserver:fmsadmin $FM_CONTAINERS" "Error setting permissions on additional directories $FM_CONTAINERS"
  executeCMD "sudo chown -R fmserver:fmsadmin $FM_BACKUPS" "Error setting permissions on additional directories $FM_BACKUPS"
ezit 99

# The SA_MASTER.fmp12 database needs to be uploaded to the server and started to setup
# some of the scheduled scripts on the server.
# You can just upload a dummy .fmp12 files that has scripts of the same name that you want to schedule.
# After the script schedules are setup, the dummy database can be deleted.
# Later on, all the production data can be copied over to the new server.

# These scripts schedules are setup later on when the admin api is turned on.
# The copying is done here as if you copy the database files, then try to start them straight
# away, filemaker doesn't like it. By copying them now, there will be a bit of time before
# trying to start the databases, 

# if [ ! -f $STATE/copy-dummy-samaster ]; then
#   sudo cp $SCRIPT_LOCATION/files/SA_MASTER_DUMMY.fmp12 $FM_DATABASES/SA_MASTER.fmp12 || { echo "Error copying dummy database"; exit 1; }
#   sudo chmod 664 $FM_DATABASES/SA_MASTER.fmp12 || { echo "Error setting permissions on dummy database"; exit 1; }
#   sudo chown fmserver:fmsadmin $FM_DATABASES/SA_MASTER.fmp12  || { echo "Error setting ownership on dummy database"; exit 1; }
#   touch $STATE/copy-dummy-samaster
# fi

## Need to enable the data api. Then rest of server config can be done via the admin api
if [ ! -f $STATE/admin-api-enabled ]; then
  executeCMD "fmsadmin enable fmdapi -u $FM_ADMIN_USER -p $FM_ADMIN_PASSWORD" "Error enabling data api"
  executeCMD "fmsadmin start fmdapi -u $FM_ADMIN_USER -p $FM_ADMIN_PASSWORD" "Error starting data api"
  touch $STATE/admin-api-enabled
fi

if [ "$FM_DOCKER" == "true" ]; then
  API_HOST="localhost"
else
  API_HOST=$HOSTNAME
fi



#This is the most basic request to tell the admin api is working. Not auth is required for this to work.
# resp=`curl -s https://$HOSTNAME/fmi/data/v2/productInfo | jq --raw-output '.messages[0].message' 2>/dev/null` 
resp=`executeCMD "curl -sk https://$API_HOST/fmi/data/v2/productInfo" "data api failed" | jq --raw-output '.messages[0].message' 2>/dev/null`
if [ "$resp" != 'OK' ]; then
  echo "Can't connect to Data API on server: $HOSTNAME"
  echo $resp
  exit 9
fi


## This is where snapshot of server was taken for the purpose of restoring to a known
# point and reruning some of the setup scripts


API_URL="$API_HOST/fmi/admin/api/v2"

#Base64 encode the username and password for the api
AUTH=$(echo -n $FM_ADMIN_USER:$FM_ADMIN_PASSWORD | base64)

# Setting token is just for testing and development
# You can't get and admin api token too often. The server stops handing them out
if [ $OPTIONS == "token" ]; then
 json=`executeCMD "curl -ks https://$API_URL/user/auth \
  -X POST \
  -H 'Authorization: Basic $AUTH' \
  -H 'Content-Type: application/json'" "data api failed"`

  ok=`echo $json | jq --raw-output '.messages[0].text'`
  if [ "$ok" != 'OK' ]; then
    echo "Can't get authorisation token"
    echo $json
    exit 9
  fi

  #Get token from json. This token is used for the remainder of requests.
  token=`echo $json | jq --raw-output '.response.token'` || { echo "Error parsing token json"; exit 1; }
  echo "token: $token"
  exit 9
fi

if [ $OPTIONS == "dev" ]; then
  #token for testing
  token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzaWQiOiIwZmI5NjBjOC1iMjU4LTQ3NTAtOWUwYS0yNGI5NjJmYzM0YzQiLCJpYXQiOjE3NDcwNTA1Nzl9.BrUmGfCPTrj9RNBPqpx_CjyAnbayK5z5tDi2cU8t7I4
  token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzaWQiOiJiYTExODExNi1mMTNlLTRjZDItYmQ3Yy1mYjhhOGRkYWVhY2IiLCJpYXQiOjE3NDcwNTI3Mjh9.fx13CjdmLCHOM_FTpVt4pgZDiYsv45-DAp1Cq3fScqs
fi

if [ $OPTIONS == "run" ]; then
 json=`executeCMD "curl -ks https://$API_URL/user/auth \
  -X POST \
  -H 'Authorization: Basic $AUTH' \
  -H 'Content-Type: application/json'" "data api failed"`

  ok=`echo $json | jq --raw-output '.messages[0].text'`
  if [ "$ok" != 'OK' ]; then
    echo "Can't get authorisation token"
    echo $json
    exit 9
  fi

  #Get token from json. This token is used for the remainder of requests.
  token=`echo $json | jq --raw-output '.response.token'` || { echo "Error parsing token json"; exit 1; }
fi

#Check token works
json=`executeCMD "curl -ks https://$API_URL/server/metadata \
 -H 'Authorization: Bearer $token' \
 -H 'Content-Type: application/json'" "data api failed"`

jsonok "Token not working"
echo "Admin API Token works. Lets continue...."


# echo "Server General Settings"
if [ ! -f $STATE/server-general-settings ]; then
  echo "Server General Settings"
  echo "Increase cache from default of 512M to 1G"
  echo "Set it so databases aren't automatically opened on server start"
  END_POINT="server/config/general"
  method="PATCH"
  data='{ "cacheSize": 1024, "openDatabasesOnStart": false }'
  api_curl
  echo "---"
  echo $json
  echo "---"
  jsonok "Couldn't set general database settings"
  
  touch $STATE/server-general-settings
fi


# Enable parallel backups
if [ "$PARALLEL_BACKUPS" == "true" ] && [ ! -f $STATE/parallel-backups ]; then
  echo "Enable Parallel Backups"
  END_POINT="server/config/parallelbackup"
  method="PATCH"
  data='{ "parallelBackupEnabled": true }'
  api_curl $method $data
  jsonok "Couldn't enable parallel backups"
  touch $STATE/parallel-backups
fi


##
## Works up to here
## "docker start" the container and continue on
exit 99

#
#
if [ ! -f $STATE/additional-folders-configured ]; then
  echo "Setting up additional folders for databases and containers"
  END_POINT="server/config/additionaldbfolder"
  method="PATCH"
  data=' { "UseOtherDatabaseRoot": true,
   "DatabaseRootPath": "filelinux:/opt/FileMaker/Data/Databases/",
   "UseDatabaseRoot1_RC": true,
   "DatabaseRootPath1_RC": "filelinux:/opt/FileMaker/Data/Containers/",
   "backupDatabaseRoot1_RC": true
  }'
  api_curl $method $data
  jsonok "Couldn't set additional database/container directories"
  touch $STATE/additional-folders-configured
fi

if [ ! -f $STATE/backup-path ]; then
  echo "Setting up backup to use seperate backup drive"
  END_POINT="server/backuppath"
  method="PATCH"
  data=' { "backupPath": "filelinux:/opt/FileMaker/Backups/" }'
  api_curl $method $data
  jsonok "Couldn't set backup location"

  touch $STATE/backup-path
fi


#
#
if [ ! -f $STATE/enable-webdirect ]; then
  echo enabling web direct
  END_POINT="webdirect/config"
  method="PATCH"
  data=' { "enabled": true }'
  api_curl $method $data
  jsonok "Couldn't enable webdirect"
  touch $STATE/enable-webdirect
fi
#
#
if [ ! -f $STATE/enable-wpe ]; then
  echo enabling web publishing engine
  END_POINT="wpe/config/1"
  method="PATCH"
  data=' { "enabled": true }'
  api_curl $method $data
  jsonok "Couldn't enable web publishing engine"
  touch $STATE/enable-wpe
fi

#
#
if [ ! -f $STATE/enable-email ]; then
  echo enabling email notifications
  END_POINT="server/notifications/email/available"
  method="PATCH"
  data=' { "emailNotification": 1 }'
  api_curl $method $data
  jsonok "Couldn't enable email notifications"
  touch $STATE/enable-email
fi

#
#
if [[ ! -f $STATE/setup-email && "$EMAIL_NOTIFICATIONS" == "true" ]]; then
  echo enabling email notifications
  END_POINT="server/notifications/email"
  method="PATCH"
  data=' { "emailSenderAddress": "'$EMAIL_SENDER'",
    "emailReplyAddress": "'$EMAIL_REPLY'",
    "emailRecipients": "'$EMAIL_RECIPIENTS'",
    "smtpServerAddress": "'$SMTP_SERVER'",
    "smtpServerPort": 587,
    "smtpUsername": "'$SMTP_USER'",
    "smtpPassword": "'$SMTP_PASSWORD'",
    "smtpAuthType": 3,
    "smtpSecurity": 4,
    "notifyLevel": 1
  }'
  api_curl $method $data
  jsonok "Couldn't configure email settings"
  touch $STATE/setup-email
fi


if [ $OPTIONS == "list" ]; then
  END_POINT="schedules"
  method="GET"
  data="{}"
  api_curl $method $data
  jsonok "list schedules"
  echo $json
  exit 9
fi

#########################################################################
##                            BACKUPS                                  ##
#########################################################################
## Setup all the backups that run in addition to the default daily backup.

# Offsite backups.
# One runs at midday, the other at 1am. The one at 1am does a verify. Each only keeps 1 generation.

# Hourly
# backup that runs every hour from 6:05 to 23:05 every day.
# 40 generations are kept

# Clone Only backup.
# There take up bugger all space, so keep heaps of them as.. why not.

if [ ! -f $STATE/configure-backups ]; then
#offsite backups
  END_POINT="schedules/backup"
  method="POST"
  data='{
  "name": "offsite_day",
  "backupType": {
    "resourceType": "ALL_DB",
    "backupTarget": "filelinux:/opt/FileMaker/Backups/",
    "maxBackups": 1,
    "clone": false,
    "verify": false
  },
  "enabled": false,
  "everyndaysType": {
    "startTimeStamp": "2024-11-16T11:30:00",
    "dailyDays": 1
  }
}'
api_curl $method $data
jsonok "Couldn't configure backup"
  data='{
  "name": "offsite_night",
  "backupType": {
    "resourceType": "ALL_DB",
    "backupTarget": "filelinux:/opt/FileMaker/Backups/",
    "maxBackups": 1,
    "clone": false,
    "verify": false
  },
  "enabled": false,
  "everyndaysType": {
    "startTimeStamp": "2024-11-16T01:00:00",
    "dailyDays": 1
  }
}'
api_curl $method $data
jsonok "Couldn't configure backup"

#Clone backup. These are very small, so can keep lots of generations.
  data='{
  "name": "clone",
  "backupType": {
    "resourceType": "ALL_DB",
    "backupTarget": "filelinux:/opt/FileMaker/FileMaker Server/Data/ClonesOnly/",
    "maxBackups": 60,
    "clone": false,
    "cloneOnly": true,
    "verify": false
  },
  "enabled": false,
  "everyndaysType": {
    "startTimeStamp": "2024-11-16T05:00:00",
    "dailyDays": 1
  }
}'
api_curl $method $data
jsonok "Couldn't configure backup"

echo "hourly backups"
  END_POINT="schedules/backup"
  method="POST"
  data='{
  "name": "hourly",
  "backupType": {
    "resourceType": "ALL_DB",
    "backupTarget": "filelinux:/opt/FileMaker/Backups/",
    "maxBackups": 40,
    "clone": false,
    "verify": false
  },
  "enabled": false,
  "everyndaysType": {
    "startTimeStamp": "2024-11-16T06:05:00",
    "dailyDays": 1,
    "repeatTask": {
      "repeatFrequency": 1,
      "repeatInterval": "HOURS",
      "endTime": "23:05:00"
    }
  }
}'

  api_curl $method $data
  jsonok "Couldn't configure backup"

  touch $STATE/configure-backups
fi


##############################
##  Setup Script Schedules  ##
##############################

if [ ! -f $STATE/configure-schedules ]; then
  echo "setup scheduled scripts"
  END_POINT="schedules/systemscript"
  method="POST"
  data='{
    "name": "Garbage Collection",
    "systemScriptType": {
      "osScript": "filelinux:/opt/FileMaker/FileMaker Server/Data/Scripts/Sys_Default_RunGarbageCollection",
      "osScriptParam": "",
      "timeout": 0
    },
    "enabled": true,
    "everyndaysType": {
      "startTimeStamp": "2024-11-16T04:15:00",
      "dailyDays": 1
    }
  }'
  api_curl $method $data
  jsonok "Couldn't setup garbage collection system script."

  END_POINT="schedules/systemscript"
  method="POST"
  data='{
    "name": "Purge Temp DB",
    "systemScriptType": {
      "osScript": "filelinux:/opt/FileMaker/FileMaker Server/Data/Scripts/Sys_Default_PurgeTempDB",
      "osScriptParam": "",
      "timeout": 0
    },
    "enabled": true,
    "everyndaysType": {
      "startTimeStamp": "2024-11-16T04:30:00",
      "dailyDays": 1
    }
  }'
  api_curl $method $data
  jsonok "Couldn't setup Purge Temp DB system script"

  # Open the dummy SA_MASTER database that was copied previously.
  fmsadmin open SA_MASTER -u $FM_ADMIN_USER -p $FM_ADMIN_PASSWORD  || { echo "Unable to open SA_MASTER db"; exit 1; }
  sleep 1

  END_POINT="schedules/filemakerscript"
  method="POST"
  data='{
    "name": "Server Master 3 hourly",
    "filemakerScriptType": {
      "autoAbort": false,
      "fmScriptName": "SERVER_MASTER",
      "fmScriptAccount": "'$SCRIPT_USER'",
      "fmScriptPassword": "'$SCRIPT_PASS'",
      "resource": "file:SA_MASTER",
      "timeout": 0
    },
    "enabled": false,
    "everyndaysType": {
      "startTimeStamp": "2024-11-16T06:00:00",
      "dailyDays": 1,
      "repeatTask": {
        "repeatFrequency": 3,
        "repeatInterval": "HOURS",
        "endTime": "23:01:00"
      }
    }
  }'
  api_curl $method $data
  jsonok "Couldn't setup SERVER_MASTER 3 hourly script"

  touch $STATE/configure-schedules

  END_POINT="schedules/filemakerscript"
  method="POST"
  data='{
    "name": "Container Cleanup",
    "filemakerScriptType": {
      "autoAbort": false,
      "fmScriptName": "Container_Cleanup",
      "fmScriptAccount": "'$SCRIPT_USER'",
      "fmScriptPassword": "'$SCRIPT_PASS'",
      "resource": "file:SA_MASTER",
      "timeout": 0
    },
    "enabled": false,
    "everyndaysType": {
      "startTimeStamp": "2024-11-16T05:00:00",
      "dailyDays": 1
    }
  }'
  api_curl $method $data
  jsonok "Couldn't setup Container Cleanup script"

  #now the scripts have been setup, the dummy SA_MASTER is no longer needed.
  fmsadmin close SA_MASTER -y -u $FM_ADMIN_USER -p $FM_ADMIN_PASSWORD
  fmsadmin remove SA_MASTER -y -u $FM_ADMIN_USER -p $FM_ADMIN_PASSWORD

  touch $STATE/configure-schedules
fi


###############################################
##  Setup External Authentication Schedules  ##
###############################################
if [[ "$EXTERNAL_AUTH" == "True"  && ! -f $STATE/external-auth ]]; then
  echo "Setting up External Auth"
  END_POINT="extauth/dbsignin/externalserver"
  method="PATCH"
  data='{ "EnableExtServerSignin": true }'
  api_curl $method $data
  jsonok "Couldn't enable External Server Signin"

  END_POINT="extauth/provider/microsoft"
  method="PATCH"
  data='{
    "AzureID": "'$OAuthID'",
    "AzureKey": "'$OAuthKey'",
    "AzureDirectoryID": "'$OAuthDirectoryID'"
  }'
  api_curl $method $data
  jsonok "Couldn't confgure Microsoft OAuth"

  END_POINT="extauth/dbsignin/microsoft"
  method="PATCH"
  data='{ "EnableMSSignin": true }'
  api_curl $method $data
  jsonok "Couldn't confgure Microsoft DB Signin"

  touch $STATE/external-auth
fi


##############################
##  Setup Systemd scripts   ##
##############################
if [ ! -f $STATE/systemd-scripts ];then
  echo
  echo "configuring systemd scripts"
  sed "s#DIR=xxx#DIR=$INSTALLED_SCRIPTS#;s#DOMAIN=xxx#DOMAIN=$HOSTNAME#;s#FMAUTH=xxx#FMAUTH=$INSTALLED_SCRIPTS/fm_auth#" \
   $SCRIPT_LOCATION/files/scripts/refreshFilemakerSSL.sh > $INSTALLED_SCRIPTS/refreshFilemakerSSL.sh

  sed "s#DIR=xxx#DIR=$INSTALLED_SCRIPTS#;s#FMAUTH=xxx#$INSTALLED_SCRIPTS/fm_auth#" \
   $SCRIPT_LOCATION/files/scripts/ServerStart.sh > $INSTALLED_SCRIPTS/ServerStart.sh

  sed "s#FM_BACKUPS#$FM_BACKUPS#;s#FMAUTH=xxx#FMAUTH=$INSTALLED_SCRIPTS/fm_auth#" \
   $SCRIPT_LOCATION/files/scripts/offsite_backup.sh > $INSTALLED_SCRIPTS/offsite_backup.sh



  cp $SECRETS/fm_auth $INSTALLED_SCRIPTS
  chmod +x $INSTALLED_SCRIPTS/*.sh
  chmod 600 $INSTALLED_SCRIPTS/fm_auth

  # Copy over all the systemd services and timers that will be setup
  sudo cp $SCRIPT_LOCATION/files/systemd/*.timer /etc/systemd/system
  sudo cp $SCRIPT_LOCATION/files/systemd/htmlemail.service /etc/systemd/system

  SERVICE=fmSSLrefresh.service; sed_systemd
  SERVICE=offsite-backup-night.service; sed_systemd
  SERVICE=startup.service; sed_systemd

  # Enable the systemd services.
  sudo systemctl enable startup
  sudo systemctl enable --now offsite-backup-night.timer
  sudo systemctl enable --now fmSSLrefresh.timer
  sudo systemctl enable --now htmlemail

  touch $STATE/systemd-scripts
fi

echo "Installation complete"
echo "To restore data, run this script with the 'restore' parameter"
echo "Logon to the filemaker admin console and enable the backups and scheduled scripts"

###########################################################
##             Restore data from current server          ##
###########################################################

#Everything in filemaker should be owned by fmserver:fmsadmin

## Database & Container files should be   664 rw-rw-r--
## Database folders should be             775 rwxrwxr-x

if [ "$OPTIONS" == "restore" ]; then
  echo
  echo
  echo "Will logon to the backup server to check it works before continuing on with installation"
  echo "If it does logon, CTRL-D to exit back and continue installation"
  read -p "Press enter to attempt logon to backup server:"

  ssh -i "$SECRETS/fm.pem" -o "StrictHostKeyChecking=accept-new" $RESTORE_SSH || { echo "Error SSHing into server to restore data"; exit 1; }
  echo "Logon to backup server successful. Continuing on with install"
  
  cp $SECRETS/fm_auth $INSTALLED_SCRIPTS || { echo "Error copying fm_auth"; exit 1; }
  cp -f $SECRETS/id_rsa $HOME_LOCATION/.ssh || { echo "Error copying id_rsa"; exit 1; }
  chmod 400 $HOME_LOCATION/.ssh/id_rsa  || { echo "Error chmodding id_rsa to 400"; exit 1; }


  echo
  echo "restore databases"
  sleep 1
  sudo rsync -ptlvzh --progress --stats --chmod=F664,D775 \
   -e "ssh -i $SECRETS/fm.pem" \
   $RESTORE_SSH:/opt/FileMaker/Data/Databases/*.fmp12 \
   /opt/FileMaker/Data/Databases/

  echo
  echo "restore containers"
  sleep 1
  sudo rsync -rptlvzh --progress --stats --chmod=F664,D775 \
   -e "ssh -i $SECRETS/fm.pem" \
   $RESTORE_SSH:/opt/FileMaker/Data/Containers/RC_Data_FMS/* \
   /opt/FileMaker/Data/Containers/RC_Data_FMS/

  sudo chown -R fmserver:fmsadmin /opt/FileMaker/Data/

  #sudo find /opt/FileMaker/Data/ -type d -exec chmod 775 {} +
  #sudo find /opt/FileMaker/Data/ -type f -exec chmod 664 {} +

fi

exit 99

## TO DO

# I just uploaded a zipped clone of SA_MASTER to the repository.
# This needs to be unzipped, and loaded up as a database so the schedule can be setup.
# Hopefully the database can be deleted without breaking the scheduled tasks??

cp $SCRIPT_LOCATION/secrets/fm_auth $INSTALLED_SCRIPTS

FILE=$SCRIPT_LOCATION/files/scripts/refreshFilemakerSSL.sh
cp $FILE $INSTALLED_SCRIPTS

sed -i -e "s/DIR=xxx/DIR=$INSTALLED_SCRIPTS/" -e "s/DOMAIN=xxx/DOMAIN=$HOSTNAME/" -e "s/FMAUTH=xxx/FMAUTH=$INSTALLED_SCRIPTS/fm_auth/" \
 $SCRIPT_LOCATION/files/scripts/refreshFilemaker.SSL.sh > $INSTALLED_SCRIPTS/refreshFilemakerSSL.sh


# gomail





exit 0
#Certbot stuff that isn't used at the moment.
if [ "$CERTBOT" == "true" ]; then
  if [ ! -f $STATE/certbot-installed ]; then
    sudo snap install --classic certbot || { echo "Error installing Certbot."; exit 1; }
    sudo ln -s /snap/bin/certbot /usr/bin/certbot
    touch $STATE/certbot-installed
  fi

  if [ ! -f $STATE/certbot-certificate ]; then
    echo "install Certbot certificate"
    sudo ufw allow http
    sudo certbot certonly --webroot \
      -w "$WEBROOTPATH" \
      -d $HOSTNAME \
      --agree-tos --non-interactive \
      -m $CERTBOT_EMAIL \
      || { echo "Error getting Certificate with Certbot."; sudo service ufw start; exit 1; }
    sudo ufw deny http

    # Setup certbot triggers to enable / disable http when it attempts to renew the certificate
    sudo cp $SCRIPT_LOCATION/files/scripts/certbot-pre-openhttp /etc/letsencrypt/renewal-hooks/pre/openhttp
    sudo cp $SCRIPT_LOCATION/files/scripts/certbot-post-closehttp /etc/letsencrypt/renewal-hooks/post/closehttp
  
    sed "s#DIR=xxx#DIR=$INSTALLED_SCRIPTS#" \
      $SCRIPT_LOCATION/files/scripts/certbot-deploy-GotNewSSL | sudo tee /etc/letsencrypt/renewal-hooks/deploy/GotNewSSL > /dev/null

    sudo chmod +x /etc/letsencrypt/renewal-hooks/pre/openhttp
    sudo chmod +x /etc/letsencrypt/renewal-hooks/post/closehttp
    sudo chmod +x /etc/letsencrypt/renewal-hooks/deploy/GotNewSSL

    touch $STATE/certbot-certificate

    logoff_rerun   # need to logoff and on again now otherwise fmsadmin doesn't work without sudo
  fi

  if [ ! -f $STATE/certbot-certificate-loaded-filemaker ]; then
    echo "Importing Certificates to filemaker:"
    # The certs in the live directory are just links to the certs.
    # fmsadmin can't handle using links to files, so we need to find where the actual certs are.
    CERTFILEPATH=$(sudo realpath "/etc/letsencrypt/live/$HOSTNAME/fullchain.pem")
    PRIVKEYPATH=$(sudo realpath "/etc/letsencrypt/live/$HOSTNAME/privkey.pem")
    sudo fmsadmin certificate import $CERTFILEPATH --keyfile $PRIVKEYPATH \
      -u $FM_ADMIN_USER -p $FM_ADMIN_PASSWORD -y || { echo "Filemaker unable to import certificate"; exit 1; }
    sudo service fmshelper restart
  
    touch $STATE/certbot-certificate-loaded-filemaker
    sudo service fmshelper restart
    logoff_rerun   # need to logoff and on again now otherwise fmsadmin doesn't work without sudo
  fi
fi  # End of all certbot installation


## At this point, the server should be up and running with an SSL cert.
